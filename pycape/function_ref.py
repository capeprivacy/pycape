"""A structured set of metadata representing a deployed Cape function.

A :class:`FunctionRef` is intended to capture any/all metadata related to a Cape
function. The metadata is generally user-supplied, provided to them with the output of
the Cape CLI's ``deploy`` command.

**Usage**

::

    fid = "asdf231lkg1324afdg"
    fchecksum = str(b"2l1h21jhgb2k1jh3".hex())
    fref = FunctionRef(fid, fchecksum)

    cape = Cape()
    cape.connect(fref)
"""
import enum
from typing import Optional


class FunctionAuthType(enum.Enum):
    """Enum representing the auth type for a function.

    The auth type determines how :class:`~pycape.cape.Cape` will supply authentication
    info for requests involving a particular function.
    """

    AUTH0 = 1
    TOKEN = 2


def get_auth_protocol(auth_type: FunctionAuthType):
    if not isinstance(auth_type, FunctionAuthType):
        raise TypeError(f"Expected FunctionAuthType, found {type(auth_type)}.")
    if auth_type == FunctionAuthType.AUTH0:
        return "cape.runtime"
    elif auth_type == FunctionAuthType.TOKEN:
        return "cape.function"
    raise ValueError(f"Unrecognized FunctionAuthType variant: {auth_type}.")


class FunctionRef:
    """A reference to a Cape function.

    Args:
        id: Required string denoting the function ID of the deployed Cape function.
            Typically given with the output of the Cape CLI's ``deploy`` command.
        checksum: Optional string denoting the checksum of the deployed Cape function.
            If supplied as part of a ``FunctionRef``, the :class:`~pycape.cape.Cape`
            client will verify that enclave responses includes a matching checksum
            whenever the ``FunctionRef`` is included in Cape requests.
        token: Optional string containing a Cape function token generated by the Cape
            CLI during ``cape token``. If ``None``, the Cape access token provided to
            :class:`~pycape.Cape` will be used by :meth:`.Cape.connect` /
            :meth:`.Cape.run` instead.
    """

    def __init__(
        self,
        id: str,
        checksum: Optional[str] = None,
        token: Optional[str] = None,
    ):
        id_ = id
        if not isinstance(id_, str):
            raise TypeError(f"Function id must be a string, found {type(id_)}.")
        self._id = id_
        self._checksum = checksum
        self._token = token
        if token is None:
            self.set_auth_type(FunctionAuthType.AUTH0)
        else:
            self.set_auth_type(FunctionAuthType.TOKEN)

    @property
    def id(self):
        return self._id

    @property
    def checksum(self):
        return self._checksum

    @property
    def token(self):
        return self._token

    @property
    def auth_type(self):
        return self._auth_type

    @property
    def auth_protocol(self):
        return self._auth_protocol

    def set_auth_type(self, auth_type: FunctionAuthType):
        """Set the :class:`FunctionAuthType` for :attr:`token`."""
        self._auth_type = auth_type
        self._auth_protocol = get_auth_protocol(auth_type)
